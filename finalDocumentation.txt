Chris BechterCIS 3207Lab02 - ShellFinal DocumentationMy thoughts:This was a very challenging lab, not being a C programmer at heart, thank goodness for stack overflow, geeksforgeeks, and family, my uncle is a programmer. I did enjoy this lab though, challenging as it may be, it did teach me more about double pointers and function pointers, which are actually pretty handy.Progress:The requirements seemed simple enough in theory, create a shell that could handle basic built in commands, I/O redirection, and piping. Simple it was not, but I feel my program persevered. The program was to also read in a batch file on execution which was a challenge in itself. The provided PDF’s helped a great deal as well as Prof. Fiore’s slides that he provided us with several examples, for example, the directory code, giving his class a little bit of a stepping stone. The first steps I took were building the loop and execute functions, I mixed in also simple parse and read functions that I had learned in CIS2107, which I just reused my old code. The parse was tricky, changing it to skip white spaces, and remove end lines, but helpful guides gave me the help I needed. Execute was tricky as well, it was basic until I began working on piping, redirection, and background processes. After I used Prof Fiore’s DIR code, found the ANSI for the clear command, I began testing execute, painfully I might add, segmentation faults over and over. This took several days to fix, but as you’ve tested, the loop and execute and those 2 commands worked. I think tackled all the rest of the built-in commands, wasn’t entirely tricky, most are straight forward. Creating the background process function was surprisingly a lot easier then I anticipated, as well as the I/O redirection, nearly the same code with slight differences, as to the I/O out has to figure out which out to use. The batch file function was an enormous pain, because it had to pretty much do the whole program in just one function, while still using the rest of the program. Piping took the longest, with the forks and keeping track of the child and parents and making sure to kill the child, over all, I’m satisfied with how everything turned out.Structure:The structure is pretty straight forward, the first thing the program tests for is if a shell has been inputted, in which case it runs through the entire batch code, executing all necessary commands and arguments. If no batch file is found, it starts the loop which activates the prompt, and sets the environment then waits for a user’s command and optional argument. The readline and parseline go into action, slicing up the command and argument and returning each, so that they can go through the loop to execute figure out all the parameters. These parameters are if a redirect was used, if a pipe is found, and is an ampersand is found for background processing. All of this is done in seconds using the provided functions, and as long as the user types something in correctly, no errors should be displayed. The shell continues until the user hits control-c or types the words exit or quit.Testing:Through out the entire process, I tested each function as they were made, this is why I wanted the read, parse, loop, and execute functions done immediately, testing each time with the dir command that was provided. Plenty of segmentation faults along the way my mismanaging memory, not using a pointer, finding out that a pointer wasn’t even needed, it was a challenge but a learning experience. After those four functions were ironed out, I tested each built in as it was made with special error codes, not the default one Prof Fiore told us to use. I made and tested the I/O functions after the built in, as well as the background which I wasn’t sure how to test but no errors works for me. Piping took the longest time, even more then the batch file function. I failed to kill the child several times, it took a lot of YouTube videos on piping and how to implement it correctly for me to finally figure out what I was doing wrong. Killed the child, closed the file descriptors. The batch file was only mainly tricky because I wasn’t freeing the argument or resetting the file descriptors. After I read online on how to approach this problem, it became much more obvious and my first successful batch file execute was quite the excitement.Overall:I found this lab very tricky, not so much with the functions, but with my own interruption and considering I haven’t had much C experience besides this class, teaching yourself a language is not an easy feat. Although I’m hoping this lab has given me enough incite to feel more confident with the next two labs. At least now I know how to write a shell right? I’m enjoying the class and these labs.